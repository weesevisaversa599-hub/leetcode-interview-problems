# 爬楼梯 (Climbing Stairs)

## 基本信息

- 题目来源：百度-后端开发、字节跳动-算法工程师、网易-游戏开发
- 难度级别：简单
- 相关标签：动态规划、数学、矩阵快速幂

## 出现次数统计

- 总次数：3次（百度1次、字节跳动1次、网易1次）

## 题目描述

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：
```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

示例 2：
```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

## 解题思路

1. **动态规划**：
   - 状态定义：`dp[i]` 表示爬到第 i 阶的不同方法数。
   - 状态转移方程：`dp[i] = dp[i-1] + dp[i-2]`，因为到达第 i 阶只能从第 i-1 阶爬 1 步或从第 i-2 阶爬 2 步。
   - 初始条件：`dp[0] = 1`（第 0 阶表示起始位置），`dp[1] = 1`，`dp[2] = 2`。

2. **优化空间**：由于只需要前两个状态，可以使用两个变量代替数组，将空间复杂度从 O(n) 降低到 O(1)。

3. **数学公式**：这是一个斐波那契数列问题，第 n 项的结果等于斐波那契数列的第 n+1 项。可以使用公式直接计算，但可能会有精度问题。

## 代码实现

### 动态规划（优化空间）

```python
def climbStairs(n):
    if n <= 2:
        return n

    prev_prev = 1  # 第 1 阶
    prev = 2       # 第 2 阶
    current = 0

    for i in range(3, n+1):
        current = prev_prev + prev
        prev_prev = prev
        prev = current

    return prev
```

### 数学公式法

```python
import math

def climbStairs(n):
    sqrt5 = math.sqrt(5)
    fibn = ((1 + sqrt5) / 2) ** (n + 1) - ((1 - sqrt5) / 2) ** (n + 1)
    return int(fibn / sqrt5)
```

## 总结

爬楼梯问题是动态规划中的经典入门题目，它展示了动态规划的核心思想：将原问题分解为子问题，通过保存子问题的解来避免重复计算。优化后的动态规划解法具有 O(n) 的时间复杂度和 O(1) 的空间复杂度，是面试中的理想解法。
